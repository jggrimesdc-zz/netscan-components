# import packages
import argparse
import datetime
import json
import psycopg2
import re
import time
import uuid
from cpe import CPE
from pyspark import SparkContext, SparkConf
from pyspark.sql import SQLContext

parser = argparse.ArgumentParser()
parser.add_argument('--bucketName', help='bucket name')
parser.add_argument('--objectKey', help='object key')
parser.add_argument('--fileSource', help='file source')
parser.add_argument('--cassandraHost', help='cassandra ip')
parser.add_argument('--rdsHost', help='rds host')
parser.add_argument('--rdsUsername', help='rds username')
parser.add_argument('--rdsPassword', help='rds password')
parser.add_argument('--jar', help='jar')
args = parser.parse_args()

conf = SparkConf().set("spark.cassandra.connection.host", args.cassandraHost).set("spark.jars",
                                                                                  "spark-cassandra-connector-assembly-2.5.1.jar")
sc = SparkContext(conf=conf)
spark = SQLContext(sc)


# spark.conf.set(s"spark.sql.catalog.mycatalog", "com.datastax.spark.connector.datasource.CassandraCatalog")

def parse_node(node: dict) -> list:
    """ Parse a single node & return a list of uris """
    children = []
    if "cpe_match" in node:
        new_children = node.get("cpe_match")
        if new_children:
            for child in new_children:
                if "operator" in child:
                    children += parse_node(child)
                else:
                    children.append({
                        "uri": child.get("cpe23Uri"),
                        "is_vuln": child.get("vulnerable"),
                        "version_start_incl": child.get("versionStartIncluding", ""),
                        "version_start_excl": child.get("versionStartExcluding", ""),
                        "version_end_incl": child.get("versionEndIncluding", ""),
                        "version_end_excl": child.get("versionEndExcluding", "")
                    })
    elif "children" in node:
        new_children = node.get("children")
        if new_children:
            for child in new_children:
                children += parse_node(child)
    return children


# Attempt to connect to RDS instance
try:
    conn = psycopg2.connect(dbname="wcaasmgmt",
                            user=args.rdsUsername,
                            password=args.rdsPassword,
                            host=args.rdsHost)
except psycopg2.OperationalError as e:
    print("ERROR: Unexpected error: Could not connect to PostgreSQL instance.")
    raise

print("SUCCESS: Connection to RDS PostgreSQL instance succeeded")

# read in data
start_time = time.time()
bucket_name = args.bucketName
object_key = args.objectKey
source_doc = args.fileSource
inputPath = 's3://' + bucket_name + "/" + object_key
print('READING DOCUMENT(S) AT ', inputPath)
df = spark.read.parquet(inputPath)
df.show()
print('TIME TO READ IN FROM S3: ', str(time.time() - start_time), 's')
data = df.toPandas().T.to_dict()

for record in list(data.values()):
    print(" ### Processing root record...")
    cve_problem_type = ""
    cve_problem_type_lang = ""
    has_exploit = False
    if len(json.loads(record.get("cve.problemtype.problemtype_data", '[{}]'))) > 0:
        if len(json.loads(record.get("cve.problemtype.problemtype_data", '[{}]'))[0].get("description", [{}])) > 0:
            cve_problem_type = \
                json.loads(record.get("cve.problemtype.problemtype_data", '[{}]'))[0].get("description", [{}])[0].get(
                    "value", "")
            cve_problem_type_lang = \
                json.loads(record.get("cve.problemtype.problemtype_data", '[{}]'))[0].get("description", [{}])[0].get(
                    "lang", "")
    for reference in json.loads(record.get("cve.references.reference_data", '[]')):
        for tag in reference.get("tags", []):
            if tag == "Exploit":
                has_exploit = True
                break
        if has_exploit:
            break
    vuln_payload = {
        "vulnerability_id": record.get("cve.CVE_data_meta.ID", ""),
        "published_at": record.get("publishedDate", datetime.datetime.now()),
        "last_modified_at": record.get("lastModifiedDate", datetime.datetime.now()),
        "cve_type": record.get("cve.data_type", ""),
        "cve_format": record.get("cve.data_format", ""),
        "cve_version": record.get("cve.data_version", ""),
        "cve_assigner": record.get("cve.CVE_data_meta.ASSIGNER", ""),
        "cve_problem_type": cve_problem_type,
        "cve_problem_type_lang": cve_problem_type_lang,
        "impact_version": record.get("impact.baseMetricV3.cvssV3.version", ""),
        "impact_vector_string": record.get("impact.baseMetricV3.cvssV3.vectorString", ""),
        "impact_attack_vector": record.get("impact.baseMetricV3.cvssV3.attackVector", ""),
        "impact_attack_complexity": record.get("impact.baseMetricV3.cvssV3.attackComplexity", ""),
        "impact_privileges_required": record.get("impact.baseMetricV3.cvssV3.privilegesRequired", ""),
        "impact_user_interaction": record.get("impact.baseMetricV3.cvssV3.userInteraction", ""),
        "impact_scope": record.get("impact.baseMetricV3.cvssV3.scope", ""),
        "impact_confidentiality_impact": record.get("impact.baseMetricV3.cvssV3.confidentialityImpact", ""),
        "impact_integrity_impact": record.get("impact.baseMetricV3.cvssV3.integrityImpact", ""),
        "impact_availability_impact": record.get("impact.baseMetricV3.cvssV3.availabilityImpact", ""),
        "impact_base_score": record.get("impact.baseMetricV3.cvssV3.baseScore", 0.0),
        "impact_base_severity": record.get("impact.baseMetricV3.cvssV3.baseSeverity", ""),
        "impact_exploitability_score": record.get("impact.baseMetricV3.exploitabilityScore", 0.0),
        "impact_score": record.get("impact.baseMetricV3.impactScore", 0.0),
        "has_exploit": has_exploit
    }

    v_placeholders = ', '.join(['%s'] * len(vuln_payload))
    excluded = []
    for i in range(len(vuln_payload)):
        excluded.append("EXCLUDED.%s" % list(vuln_payload.keys())[i])
    v_excluded = ', '.join(excluded[1:])
    v_columns = ', '.join(vuln_payload.keys())
    v_update_columns = ', '.join(list(vuln_payload.keys())[1:])
    v_sql = "INSERT INTO %s ( %s ) VALUES ( %s ) ON CONFLICT ON CONSTRAINT %s DO UPDATE SET ( %s ) = ( %s )" % (
        'enrichment.vulnerability', v_columns, v_placeholders, 'vulnerability_pkey', v_update_columns, v_excluded)

    with conn.cursor() as cur:
        cur.execute(v_sql, list(vuln_payload.values()))

    for node in json.loads(record.get("configurations.nodes", '[]')):
        print(" ### Processing configuration nodes...")
        for cpe_and_more in parse_node(node):
            # To correct "NotImplementedError: Version of CPE not implemented" caused by non-escaped characters
            if "?" in cpe_and_more["uri"]:
                cpe_and_more["uri"] = re.sub(r'(?<!\\)(?:\\\\)*(\?)', '\?', cpe_and_more["uri"])
            cpe_list = CPE(cpe_and_more["uri"])
            vuln_serv_payload = {
                "service_id": str(uuid.uuid4()),
                "vulnerability_id": vuln_payload.get("vulnerability_id"),
                "cpe_uri": cpe_and_more["uri"],
                "cpe_part": str(cpe_list[0]),
                "cpe_vendor": str(cpe_list[1]),
                "cpe_product": str(cpe_list[2]),
                "cpe_product_version": str(cpe_list[3]),
                "cpe_update": str(cpe_list[4]),
                "cpe_edition": str(cpe_list[5]),
                "cpe_language": str(cpe_list[6]),
                "cpe_sw_edition": str(cpe_list[7]),
                "cpe_target_sw": str(cpe_list[8]),
                "cpe_target_hw": str(cpe_list[9]),
                "cpe_other": str(cpe_list[10]),
                "version_start_including": cpe_and_more["version_start_incl"],
                "version_start_excluding": cpe_and_more["version_start_excl"],
                "version_end_including": cpe_and_more["version_end_incl"],
                "version_end_excluding": cpe_and_more["version_end_excl"],
                "is_vulnerable": cpe_and_more["is_vuln"]
            }

            vs_placeholders = ', '.join(['%s'] * len(vuln_serv_payload))
            vs_columns = ', '.join(vuln_serv_payload.keys())
            vs_sql = "INSERT INTO %s ( %s ) VALUES ( %s )" % (
                'enrichment.vulnerable_service', vs_columns, vs_placeholders)

            with conn.cursor() as cur:
                cur.execute(vs_sql, list(vuln_serv_payload.values()))

    for reference in json.loads(record.get("cve.references.reference_data", '[]')):
        print(" ### Processing reference data...")
        reference_payload = {
            "reference_id": str(uuid.uuid4()),
            "vulnerability_id": vuln_payload.get("vulnerability_id"),
            "url": reference.get("url", ""),
            "name": reference.get("name", ""),
            "source": reference.get("refsource", "")
        }

        r_placeholders = ', '.join(['%s'] * len(reference_payload))
        r_columns = ', '.join(reference_payload.keys())
        r_sql = "INSERT INTO %s ( %s ) VALUES ( %s )" % ('enrichment.reference', r_columns, r_placeholders)

        with conn.cursor() as cur:
            cur.execute(r_sql, list(reference_payload.values()))

        for tag in reference.get("tags", []):
            print(" ### Processing reference tags...")
            tag_id = ""

            with conn.cursor() as cur:
                cur.execute("SELECT * FROM enrichment.reference_tag WHERE name = %s LIMIT 1", (tag,))
                old_tag = cur.fetchone()
            if old_tag is None:
                ref_tag_payload = {
                    "reference_tag_id": str(uuid.uuid4()),
                    "name": tag,
                    "created_at": datetime.datetime.now()
                }

                rt_placeholders = ', '.join(['%s'] * len(ref_tag_payload))
                rt_columns = ', '.join(ref_tag_payload.keys())
                rt_sql = "INSERT INTO %s ( %s ) VALUES ( %s )" % (
                    'enrichment.reference_tag', rt_columns, rt_placeholders)

                with conn.cursor() as cur:
                    cur.execute(rt_sql, list(ref_tag_payload.values()))
                conn.commit()

                tag_id = ref_tag_payload.get("reference_tag_id")
            else:
                tag_id = old_tag[0]

            ref_tags_payload = {
                "reference_id": reference_payload.get("reference_id"),
                "reference_tag_id": tag_id
            }

            rts_placeholders = ', '.join(['%s'] * len(ref_tags_payload))
            rts_columns = ', '.join(ref_tags_payload.keys())
            rts_sql = "INSERT INTO %s ( %s ) VALUES ( %s )" % (
                'enrichment.reference_tags', rts_columns, rts_placeholders)

            with conn.cursor() as cur:
                cur.execute(rts_sql, list(ref_tags_payload.values()))
conn.commit()
