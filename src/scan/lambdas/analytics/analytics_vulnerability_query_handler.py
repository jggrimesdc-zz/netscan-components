from __future__ import print_function

import json
import os
import psycopg2
import re
from math import isnan
from scan_api_lib import SecretUtils


def lambda_handler(event, context):
    secret_name = os.environ.get("DB_SECRET_NAME")
    region = os.environ.get("AWS_REGION")
    dbconfig = json.loads(SecretUtils.get_secret(secret_name, region)["SecretString"])

    # Attempt to connect to RDS instance
    try:
        conn = psycopg2.connect(dbname="wcaasmgmt",
                                user=dbconfig["username"],
                                password=dbconfig["password"],
                                host=dbconfig["host"])
    except psycopg2.OperationalError as e:
        print("ERROR: Unexpected error: Could not connect to PostgreSQL instance.")
        return {
            "isBase64Encoded": False,
            "statusCode": 500,
            "headers": {},
            "multiValueHeaders": {},
            "body": json.dumps({
                "errorMessage": "RDS Connection Error",
                "errorDetails": f"Error connecting to the RDS instance.  "
                                f"Response: {e}"
            })
        }

    print("SUCCESS: Connection to RDS PostgreSQL instance succeeded")

    vulnerability = event["queryStringParameters"].get("vulnerability")
    vendor = event["queryStringParameters"].get("vendor")
    product = event["queryStringParameters"].get("product")
    version = event["queryStringParameters"].get("version")
    exploits = event["queryStringParameters"].get("exploits")
    page_val = event["queryStringParameters"].get("page") or "1"
    per_page_val = event["queryStringParameters"].get("per_page") or "50"
    if type(exploits) != bool:
        exploits = False

    # determine query type
    error_body = None
    if not vulnerability and not vendor and not product and not version:
        error_body = "Invalid Query Path = either 'vulnerability' OR 'vendor' query params must be populated"
    elif vulnerability and (vendor or product or version):
        error_body = "Invalid Query Path - ONLY 'vulnerability' OR ('vendor', 'product', and 'version') may be used to query"
    elif not vulnerability and not vendor and (product or version):
        error_body = "Invalid Query Path - 'vendor' required to query by 'product'; 'product' required to query by 'version'"
    elif vulnerability and not re.compile(r"^CVE-[0-9]{4}-[0-9]+$").match(vulnerability):
        error_body = "Invalid Query Parameter - 'vulnerability' must match pattern of 'CVE-####-#...'"
    elif vendor and not re.compile(r"^\S+$").match(vendor):
        error_body = "Invalid Query Parameter - 'vendor' must be a string of non-whitespace characters, like 'microsoft'"
    elif vendor and not re.compile(r"^\S+$").match(product):
        error_body = "Invalid Query Parameter - 'product' must be a string of non-whitespace characters, like 'windows'"
    elif version and not re.compile(r"^\S+$").match(version):
        error_body = "Invalid Query Parameter - 'version' must be a string of non-whitespace characters, like '8.8.4'"

    if error_body is not None:
        return {
            "isBase64Encoded": False,
            "statusCode": 204,
            "headers": {},
            "multiValueHeaders": {},
            "body": error_body
        }

    if vulnerability:
        sql = "SELECT * FROM enrichment.vulnerability WHERE vulnerability_id = %s AND has_exploit = %s"
        execution_params = [sql, (vulnerability, True)]
    else:
        sql = "SELECT * FROM enrichment.vulnerability v"
        sql += " WHERE EXISTS (SELECT * FROM enrichment.vulnerable_service vs WHERE v.vulnerability_id = vs.vulnerability_id"
        sql += " AND LOWER(cpe_vendor) = LOWER(%s)"
        if product:
            sql += " AND LOWER(cpe_product) = LOWER(%s)"
            if version:
                sql += " AND cpe_product_version = %s"
                execution_params = [sql, (vendor, product, version)]
            else:
                execution_params = [sql, (vendor, product)]
        else:
            execution_params = [sql, (vendor)]

        execution_params[0] += ")"

        if exploits:
            tmp = list(execution_params[1])
            tmp.append(True)
            execution_params[1] = tuple(tmp)
            execution_params[0] += " AND has_exploit = %s"

    page = int(page_val) if page_val.isnumeric() else 1
    per_page = int(per_page_val) if per_page_val.isnumeric() else 50

    tmp = list(execution_params[1])
    tmp.append(page * per_page)
    tmp.append(per_page + 1)
    execution_params[1] = tuple(tmp)
    execution_params[0] += " OFFSET %s LIMIT %s"

    rows = []
    with conn.cursor() as cur:
        cur.execute(*execution_params)
        try:
            rows = cur.fetchall()
        except psycopg2.ProgrammingError as e:
            print("NO RESULTS")

    columns = (
        'vulnerability_id',
        'published_at',
        'last_modified_at',
        'cve_type',
        "cve_format",
        "cve_version",
        "cve_assigner",
        "cve_problem_type",
        "cve_problem_type_lang",
        "cve_description",
        "cve_description_lang",
        "impact_version",
        "impact_vector_string",
        "impact_attack_vector",
        "impact_attack_complexity",
        "impact_privileges_required",
        "impact_user_interaction",
        "impact_scope",
        "impact_confidentiality_impact",
        "impact_integrity_impact",
        "impact_availability_impact",
        "impact_base_score",
        "impact_base_severity",
        "impact_exploitability_score",
        "impact_score",
        "has_exploit"
    )

    results = {
        "meta": {},
        "items": []
    }
    results["meta"]["hasMore"] = len(rows[per_page:]) >= 1

    for row in rows[:per_page]:
        raw_row = json.loads(json.dumps(row, indent=4, sort_keys=True, default=str))
        raw_row[1] = raw_row[1].replace(" ", "T")
        raw_row[2] = raw_row[2].replace(" ", "T")

        # Replace invalid json values with defaults - float(NaN) defaults to 0
        cleaned_row = [0 if (type(x) == float and isnan(x)) else x for x in raw_row]
        results["items"].append(dict(zip(columns, cleaned_row)))

    response_body = json.dumps(results)
    if len(results["items"]) == 0:
        status_code = 204
    else:
        status_code = 200

    return {
        "isBase64Encoded": False,
        "statusCode": status_code,
        "headers": {},
        "multiValueHeaders": {},
        "body": response_body
    }
